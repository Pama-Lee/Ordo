syntax = "proto3";

package ordo.v1;

option java_package = "com.ordo.proto.v1";
option java_multiple_files = true;
option go_package = "github.com/pama-lee/ordo/proto/v1";

// =============================================================================
// Ordo Rule Engine Service
// =============================================================================
// This service is for business application callers.
// Rule management (Create/Update/Delete) is handled via HTTP Admin API only.
//
// Multi-tenancy: All methods support multi-tenancy through gRPC metadata.
// Pass "x-tenant-id" in the metadata to specify the tenant.
// If not provided, the server's default tenant will be used.

service OrdoService {
  // Execute a ruleset with given input
  rpc Execute(ExecuteRequest) returns (ExecuteResponse);
  
  // Execute a ruleset with multiple inputs (batch execution)
  // More efficient than calling Execute multiple times:
  // - Single RPC call for all inputs
  // - Single lock acquisition for ruleset lookup
  // - Optional parallel execution
  rpc BatchExecute(BatchExecuteRequest) returns (BatchExecuteResponse);
  
  // Get a ruleset by name (read-only)
  rpc GetRuleSet(GetRuleSetRequest) returns (GetRuleSetResponse);
  
  // List all available rulesets (read-only)
  rpc ListRuleSets(ListRuleSetsRequest) returns (ListRuleSetsResponse);
  
  // Evaluate an expression (debug endpoint)
  rpc Eval(EvalRequest) returns (EvalResponse);
  
  // Health check
  rpc Health(HealthRequest) returns (HealthResponse);
}

// =============================================================================
// Execute Messages
// =============================================================================

message ExecuteRequest {
  // Name of the ruleset to execute
  string ruleset_name = 1;
  
  // Input data as JSON string
  string input_json = 2;
  
  // Whether to include execution trace in response
  bool include_trace = 3;
}

message ExecuteResponse {
  // Execution result code (e.g., "APPROVED", "REJECTED")
  string code = 1;
  
  // Human-readable result message
  string message = 2;
  
  // Output data as JSON string
  string output_json = 3;
  
  // Execution duration in microseconds
  uint64 duration_us = 4;
  
  // Execution trace (if requested)
  ExecutionTrace trace = 5;
}

message ExecutionTrace {
  // Path of step IDs taken during execution
  string path = 1;
  
  // Details of each step executed
  repeated StepTrace steps = 2;
}

// =============================================================================
// Batch Execute Messages
// =============================================================================

message BatchExecuteRequest {
  // Name of the ruleset to execute
  string ruleset_name = 1;
  
  // List of inputs as JSON strings
  repeated string inputs_json = 2;
  
  // Execution options
  BatchExecuteOptions options = 3;
}

message BatchExecuteOptions {
  // Whether to execute in parallel (default: true)
  bool parallel = 1;
  
  // Whether to include execution trace in results (default: false)
  bool include_trace = 2;
}

message BatchExecuteResponse {
  // Results for each input (in same order as inputs)
  repeated BatchExecuteResultItem results = 1;
  
  // Summary statistics
  BatchExecuteSummary summary = 2;
}

message BatchExecuteResultItem {
  // Execution result code (e.g., "APPROVED", "REJECTED", or "error" if failed)
  string code = 1;
  
  // Human-readable result message
  string message = 2;
  
  // Output data as JSON string
  string output_json = 3;
  
  // Execution duration in microseconds
  uint64 duration_us = 4;
  
  // Execution trace (if requested)
  ExecutionTrace trace = 5;
  
  // Error message (if failed)
  string error = 6;
}

message BatchExecuteSummary {
  // Total number of inputs
  uint32 total = 1;
  
  // Number of successful executions
  uint32 success = 2;
  
  // Number of failed executions
  uint32 failed = 3;
  
  // Total execution time in microseconds (sum of all individual durations)
  uint64 total_duration_us = 4;
}

message StepTrace {
  // Step ID
  string step_id = 1;
  
  // Step name
  string step_name = 2;
  
  // Step duration in microseconds
  uint64 duration_us = 3;
  
  // Step result (for decision steps: "true"/"false", for terminal: "terminal")
  string result = 4;
}

// =============================================================================
// RuleSet Messages
// =============================================================================

message GetRuleSetRequest {
  // Name of the ruleset
  string name = 1;
}

message GetRuleSetResponse {
  // RuleSet definition as JSON
  string ruleset_json = 1;
  
  // Version of the ruleset
  string version = 2;
  
  // Description
  string description = 3;
  
  // Number of steps in the ruleset
  uint32 step_count = 4;
}

message ListRuleSetsRequest {
  // Optional: filter by prefix
  string name_prefix = 1;
  
  // Maximum number of results (0 = no limit)
  uint32 limit = 2;
}

message ListRuleSetsResponse {
  // List of ruleset summaries
  repeated RuleSetSummary rulesets = 1;
  
  // Total count
  uint32 total_count = 2;
}

message RuleSetSummary {
  // RuleSet name
  string name = 1;
  
  // Version
  string version = 2;
  
  // Description
  string description = 3;
  
  // Number of steps
  uint32 step_count = 4;
}

// =============================================================================
// Eval Messages (Debug)
// =============================================================================

message EvalRequest {
  // Expression to evaluate
  string expression = 1;
  
  // Context data as JSON string
  string context_json = 2;
}

message EvalResponse {
  // Result value as JSON
  string result_json = 1;
  
  // Parsed expression (for debugging)
  string parsed_expression = 2;
}

// =============================================================================
// Typed Execute Messages (Schema-Aware JIT)
// =============================================================================
// These messages support typed context for high-performance execution
// using Schema-Aware JIT compilation with direct field access.

message TypedExecuteRequest {
  // Name of the ruleset to execute
  string ruleset_name = 1;
  
  // Schema name for the context (must be registered on server)
  string schema_name = 2;
  
  // Context data as protobuf bytes
  // The server will decode this using the registered schema
  bytes context_bytes = 3;
  
  // Whether to include execution trace in response
  bool include_trace = 4;
}

message TypedEvalRequest {
  // Expression to evaluate
  string expression = 1;
  
  // Schema name for the context
  string schema_name = 2;
  
  // Context data as protobuf bytes
  bytes context_bytes = 3;
}

message TypedEvalResponse {
  // Result value as f64 (all JIT results are numeric)
  double result = 1;
  
  // Whether JIT was used (true) or fell back to VM (false)
  bool jit_used = 2;
  
  // Execution time in nanoseconds
  uint64 duration_ns = 3;
}

// =============================================================================
// Health Messages
// =============================================================================

message HealthRequest {
  // Optional: specific service to check
  string service = 1;
}

message HealthResponse {
  // Service status
  enum Status {
    UNKNOWN = 0;
    SERVING = 1;
    NOT_SERVING = 2;
  }
  
  Status status = 1;
  
  // Server version
  string version = 2;
  
  // Number of loaded rulesets
  uint32 ruleset_count = 3;
  
  // Server uptime in seconds
  uint64 uptime_seconds = 4;
}

