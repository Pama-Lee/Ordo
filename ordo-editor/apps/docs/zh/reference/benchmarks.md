# 性能基准测试

本文档总结了 Ordo 规则引擎的性能基准测试结果，包含**优化前后的对比数据**。

## 执行摘要

优化后，Ordo 实现了：

- **FunctionRegistry 初始化快 862 倍**
- **Evaluator 初始化快 734 倍**
- **RuleExecutor 初始化快 103 倍**
- **每秒 284 万次**规则执行吞吐量

## 核心优化成果 (实测数据)

### 初始化性能 - 最关键的优化

| 组件                        | 优化前  | 优化后      | 提升幅度            |
| --------------------------- | ------- | ----------- | ------------------- |
| **FunctionRegistry::new()** | 3.87 µs | **4.49 ns** | **862x ↑ (99.88%)** |
| **Evaluator::new()**        | 3.59 µs | **4.89 ns** | **734x ↑ (99.86%)** |
| **RuleExecutor::new()**     | 3.76 µs | **36.5 ns** | **103x ↑ (99.01%)** |

> **影响**: 每次请求的初始化开销从 ~11µs 降低到 ~46ns，**降低了 239 倍**

### 为什么这个优化很重要？

在生产环境中，每个规则执行请求都需要创建这些组件：

- 优化前：每请求 ~11,000 ns 初始化开销
- 优化后：每请求 ~46 ns 初始化开销
- **在 100K QPS 下的节省**: 每秒节省 ~1.1 秒 CPU 时间

## 关键性能指标 (KPI)

| 指标               | 数值               | 说明                 |
| ------------------ | ------------------ | -------------------- |
| **简单规则执行**   | ~352 ns            | 已编译的最小规则集   |
| **中等规则执行**   | ~2.03 µs           | 已编译，3层决策树    |
| **二进制编译执行** | ~459 ns            | Cranelift JIT 编译后 |
| **批处理吞吐量**   | **2.84 M ops/sec** | 1K 批次顺序执行      |
| **函数注册表创建** | ~4.5 ns            | 全局单例优化后       |
| **len() 函数调用** | ~4.4 ns            | 快速路径优化         |

## 详细基准测试结果

### 1. 表达式解析 (Expression Parsing)

将表达式字符串解析为 AST 的时间。

| 表达式类型                                    | 时间    | 复杂度 |
| --------------------------------------------- | ------- | ------ |
| `age > 18` (简单字段比较)                     | 1.07 µs | 低     |
| `status == "active"` (字符串比较)             | 951 ns  | 低     |
| `age > 18 && status == "active"` (逻辑与)     | 2.00 µs | 中     |
| `age < 13 \|\| age > 65` (逻辑或)             | 2.03 µs | 中     |
| `user.profile.level == "gold"` (嵌套字段)     | 1.05 µs | 低     |
| `status in ["active", "pending"]` (in 运算符) | 1.81 µs | 中     |
| `len(items) > 0` (函数调用)                   | 1.64 µs | 中     |
| `price * quantity * (1 - discount)` (算术)    | 1.48 µs | 中     |
| `if premium then x * 0.9 else x` (条件)       | 2.57 µs | 高     |
| `coalesce(a, b, "default")` (合并)            | 2.43 µs | 高     |
| 复杂组合表达式                                | 3.25 µs | 高     |

**关键洞察**: 表达式解析是一次性开销。通过调用 `RuleSet::compile()` 预编译，可在运行时完全避免此开销。

### 2. 表达式求值 (Expression Evaluation)

对预解析 AST 进行求值的时间。

| 表达式类型              | 时间     | 吞吐量    |
| ----------------------- | -------- | --------- |
| 字段比较 (`value > 50`) | 67.1 ns  | ~14.9 M/s |
| 嵌套字段访问            | 79.7 ns  | ~12.5 M/s |
| 逻辑与                  | 147.9 ns | ~6.8 M/s  |
| 逻辑或 (短路)           | 141.7 ns | ~7.1 M/s  |
| 算术运算                | 67.8 ns  | ~14.7 M/s |
| 函数调用 (`len`)        | 160.5 ns | ~6.2 M/s  |
| 函数调用 (`sum`)        | 163.8 ns | ~6.1 M/s  |
| 条件表达式              | 74.7 ns  | ~13.4 M/s |
| 数组包含检查            | 149.9 ns | ~6.7 M/s  |

**关键洞察**: 表达式求值非常快，单次求值在 67-164 纳秒范围内。

### 3. 规则执行 (Rule Execution)

端到端规则执行性能对比。

| 场景                | 未编译  | 已编译      | 提升     |
| ------------------- | ------- | ----------- | -------- |
| 最小规则集 (1 决策) | 1.54 µs | **352 ns**  | **4.4x** |
| 中等规则集 (3 决策) | 6.23 µs | **2.03 µs** | **3.1x** |
| 二进制编译执行      | -       | **459 ns**  | -        |

**关键洞察**:

- 预编译规则集可获得 3-4x 的性能提升
- 对于生产环境，**必须**调用 `compile()` 方法
- 二进制编译(Cranelift JIT)提供最佳性能

### 4. 内置函数 (Built-in Functions)

优化后的快速路径函数调用性能。

| 函数           | 时间    | 说明       |
| -------------- | ------- | ---------- |
| `len(string)`  | 4.43 ns | 字符串长度 |
| `len(array)`   | 4.41 ns | 数组长度   |
| `is_null(x)`   | 4.36 ns | 空值检查   |
| `abs(-42)`     | 6.05 ns | 绝对值     |
| `sum([...])`   | 7.25 ns | 数组求和   |
| `min(a,b,c)`   | 10.1 ns | 最小值     |
| `max(a,b,c)`   | 9.79 ns | 最大值     |
| `first([...])` | 20.8 ns | 首元素     |
| `last([...])`  | 20.8 ns | 末元素     |
| `avg([...])`   | 21.3 ns | 平均值     |
| `type(x)`      | 43.1 ns | 类型检查   |
| `upper(str)`   | 81.9 ns | 转大写     |
| `lower(str)`   | 82.9 ns | 转小写     |

**关键洞察**:

- 常用函数 (`len`, `is_null`, `abs`) 均在 10ns 以下
- 全局单例 `FunctionRegistry` 避免了重复初始化

### 5. 初始化开销 (Initialization Overhead)

组件创建的一次性开销。

| 组件                      | 时间        | 说明           |
| ------------------------- | ----------- | -------------- |
| `FunctionRegistry::new()` | **4.49 ns** | 全局单例引用   |
| `Evaluator::new()`        | 4.89 ns     | 轻量级         |
| `RuleExecutor::new()`     | 36.5 ns     | 包含 Evaluator |
| `Context::from_json()`    | 404 ns      | JSON 解析      |
| `RuleSet::compile()`      | 1.65 µs     | 预编译表达式   |

**关键洞察**:

- `FunctionRegistry::new()` 优化后仅需 ~4ns (之前需要 100+ns 初始化所有内置函数)
- 编译开销 (1.65 µs) 是一次性的，执行时无需重复

### 6. 批处理吞吐量 (Throughput)

大规模批量执行性能。

| 批次大小      | 总时间  | 吞吐量             |
| ------------- | ------- | ------------------ |
| 1,000 次执行  | 352 µs  | **2.84 M ops/sec** |
| 10,000 次执行 | 3.58 ms | **2.79 M ops/sec** |

**关键洞察**:

- 稳定的每秒 280 万次操作吞吐量
- 线性扩展，无明显性能退化

### 7. 复杂度扩展 (Scaling)

随分支数量增加的性能变化。

| 分支数 | 执行时间 | 每分支开销  |
| ------ | -------- | ----------- |
| 5      | 642 ns   | 128 ns/分支 |
| 10     | 980 ns   | 98 ns/分支  |
| 20     | 1.65 µs  | 82 ns/分支  |
| 50     | 2.08 µs  | 42 ns/分支  |

**关键洞察**:

- 分支评估具有亚线性扩展特性
- 50 个分支的规则仅需 ~2µs

## 优化对比总结 (实测数据)

### 初始化优化 (最重要)

| 组件                    | 优化前      | 优化后      | 提升       |
| ----------------------- | ----------- | ----------- | ---------- |
| FunctionRegistry::new() | **3.87 µs** | **4.49 ns** | **862x ↑** |
| Evaluator::new()        | **3.59 µs** | **4.89 ns** | **734x ↑** |
| RuleExecutor::new()     | **3.76 µs** | **36.5 ns** | **103x ↑** |

### 规则执行优化

| 测试项          | 优化前  | 优化后  | 变化  |
| --------------- | ------- | ------- | ----- |
| 简单规则执行    | 1.82 µs | 1.81 µs | -0.7% |
| 复杂规则执行    | 3.53 µs | 3.50 µs | -1.0% |
| 吞吐量 (1K批次) | 1.82 ms | 1.81 ms | -0.6% |

### 内置函数优化

| 函数    | 优化前    | 优化后   | 变化      |
| ------- | --------- | -------- | --------- |
| upper() | 103.56 ns | 98.62 ns | **-4.8%** |
| abs()   | 7.21 ns   | 7.00 ns  | **-2.9%** |
| avg()   | 23.69 ns  | 24.16 ns | +2.0%     |
| sum()   | 7.97 ns   | 8.33 ns  | +4.5%     |

### 优化技术总结

| 优化技术                     | 说明                             | 影响             |
| ---------------------------- | -------------------------------- | ---------------- |
| 全局单例 FunctionRegistry    | 使用 `OnceLock` 延迟初始化       | 862x 初始化加速  |
| `Cow<'static, str>` 错误消息 | 避免静态错误消息的内存分配       | 减少 heap 分配   |
| 快速路径函数分发             | 常用函数绕过 HashMap 查找        | ~5% 函数调用加速 |
| ExecutionOptions             | 运行时参数覆盖，避免克隆 RuleSet | 批处理零克隆     |

## 运行基准测试

```bash
# 运行完整基准测试套件
cargo bench --bench unified_bench

# 运行特定测试组
cargo bench --bench unified_bench -- "rule_execution"

# 保存基线
cargo bench --bench unified_bench -- --save-baseline my_baseline

# 与基线比较
cargo bench --bench unified_bench -- --baseline my_baseline

# 使用报告生成脚本
./scripts/bench-report.sh all
```

## 建议的生产配置

```rust
// 1. 预编译规则集 (必须)
let mut ruleset = RuleSet::from_json(&json)?;
ruleset.compile()?;  // 预编译所有表达式

// 2. 复用执行器 (推荐)
let executor = RuleExecutor::new();  // 创建一次，多次使用

// 3. 使用 ExecutionOptions 进行运行时覆盖
let options = ExecutionOptions {
    timeout_ms: Some(1000),
    enable_trace: false,
    ..Default::default()
};
let result = executor.execute_with_options(&ruleset, input, Some(&options));

// 4. 对于极致性能，使用二进制编译
let compiled = RuleSetCompiler::compile(&ruleset)?;
let binary_executor = CompiledRuleExecutor::new();
let result = binary_executor.execute(&compiled, input);
```

## 测试环境

- **平台**: macOS (Apple Silicon)
- **Rust 版本**: stable
- **基准测试框架**: criterion

---

_报告由 Ordo 基准测试套件自动生成_
