// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.2
// source: ordo.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	OrdoService_Execute_FullMethodName      = "/ordo.v1.OrdoService/Execute"
	OrdoService_BatchExecute_FullMethodName = "/ordo.v1.OrdoService/BatchExecute"
	OrdoService_GetRuleSet_FullMethodName   = "/ordo.v1.OrdoService/GetRuleSet"
	OrdoService_ListRuleSets_FullMethodName = "/ordo.v1.OrdoService/ListRuleSets"
	OrdoService_Eval_FullMethodName         = "/ordo.v1.OrdoService/Eval"
	OrdoService_Health_FullMethodName       = "/ordo.v1.OrdoService/Health"
)

// OrdoServiceClient is the client API for OrdoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OrdoServiceClient interface {
	// Execute a ruleset with given input
	Execute(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (*ExecuteResponse, error)
	// Execute a ruleset with multiple inputs (batch execution)
	// More efficient than calling Execute multiple times:
	// - Single RPC call for all inputs
	// - Single lock acquisition for ruleset lookup
	// - Optional parallel execution
	BatchExecute(ctx context.Context, in *BatchExecuteRequest, opts ...grpc.CallOption) (*BatchExecuteResponse, error)
	// Get a ruleset by name (read-only)
	GetRuleSet(ctx context.Context, in *GetRuleSetRequest, opts ...grpc.CallOption) (*GetRuleSetResponse, error)
	// List all available rulesets (read-only)
	ListRuleSets(ctx context.Context, in *ListRuleSetsRequest, opts ...grpc.CallOption) (*ListRuleSetsResponse, error)
	// Evaluate an expression (debug endpoint)
	Eval(ctx context.Context, in *EvalRequest, opts ...grpc.CallOption) (*EvalResponse, error)
	// Health check
	Health(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error)
}

type ordoServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOrdoServiceClient(cc grpc.ClientConnInterface) OrdoServiceClient {
	return &ordoServiceClient{cc}
}

func (c *ordoServiceClient) Execute(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (*ExecuteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteResponse)
	err := c.cc.Invoke(ctx, OrdoService_Execute_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ordoServiceClient) BatchExecute(ctx context.Context, in *BatchExecuteRequest, opts ...grpc.CallOption) (*BatchExecuteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchExecuteResponse)
	err := c.cc.Invoke(ctx, OrdoService_BatchExecute_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ordoServiceClient) GetRuleSet(ctx context.Context, in *GetRuleSetRequest, opts ...grpc.CallOption) (*GetRuleSetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRuleSetResponse)
	err := c.cc.Invoke(ctx, OrdoService_GetRuleSet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ordoServiceClient) ListRuleSets(ctx context.Context, in *ListRuleSetsRequest, opts ...grpc.CallOption) (*ListRuleSetsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListRuleSetsResponse)
	err := c.cc.Invoke(ctx, OrdoService_ListRuleSets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ordoServiceClient) Eval(ctx context.Context, in *EvalRequest, opts ...grpc.CallOption) (*EvalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EvalResponse)
	err := c.cc.Invoke(ctx, OrdoService_Eval_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ordoServiceClient) Health(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthResponse)
	err := c.cc.Invoke(ctx, OrdoService_Health_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OrdoServiceServer is the server API for OrdoService service.
// All implementations must embed UnimplementedOrdoServiceServer
// for forward compatibility.
type OrdoServiceServer interface {
	// Execute a ruleset with given input
	Execute(context.Context, *ExecuteRequest) (*ExecuteResponse, error)
	// Execute a ruleset with multiple inputs (batch execution)
	// More efficient than calling Execute multiple times:
	// - Single RPC call for all inputs
	// - Single lock acquisition for ruleset lookup
	// - Optional parallel execution
	BatchExecute(context.Context, *BatchExecuteRequest) (*BatchExecuteResponse, error)
	// Get a ruleset by name (read-only)
	GetRuleSet(context.Context, *GetRuleSetRequest) (*GetRuleSetResponse, error)
	// List all available rulesets (read-only)
	ListRuleSets(context.Context, *ListRuleSetsRequest) (*ListRuleSetsResponse, error)
	// Evaluate an expression (debug endpoint)
	Eval(context.Context, *EvalRequest) (*EvalResponse, error)
	// Health check
	Health(context.Context, *HealthRequest) (*HealthResponse, error)
	mustEmbedUnimplementedOrdoServiceServer()
}

// UnimplementedOrdoServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOrdoServiceServer struct{}

func (UnimplementedOrdoServiceServer) Execute(context.Context, *ExecuteRequest) (*ExecuteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Execute not implemented")
}
func (UnimplementedOrdoServiceServer) BatchExecute(context.Context, *BatchExecuteRequest) (*BatchExecuteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BatchExecute not implemented")
}
func (UnimplementedOrdoServiceServer) GetRuleSet(context.Context, *GetRuleSetRequest) (*GetRuleSetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRuleSet not implemented")
}
func (UnimplementedOrdoServiceServer) ListRuleSets(context.Context, *ListRuleSetsRequest) (*ListRuleSetsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListRuleSets not implemented")
}
func (UnimplementedOrdoServiceServer) Eval(context.Context, *EvalRequest) (*EvalResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Eval not implemented")
}
func (UnimplementedOrdoServiceServer) Health(context.Context, *HealthRequest) (*HealthResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Health not implemented")
}
func (UnimplementedOrdoServiceServer) mustEmbedUnimplementedOrdoServiceServer() {}
func (UnimplementedOrdoServiceServer) testEmbeddedByValue()                     {}

// UnsafeOrdoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OrdoServiceServer will
// result in compilation errors.
type UnsafeOrdoServiceServer interface {
	mustEmbedUnimplementedOrdoServiceServer()
}

func RegisterOrdoServiceServer(s grpc.ServiceRegistrar, srv OrdoServiceServer) {
	// If the following call panics, it indicates UnimplementedOrdoServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&OrdoService_ServiceDesc, srv)
}

func _OrdoService_Execute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrdoServiceServer).Execute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrdoService_Execute_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrdoServiceServer).Execute(ctx, req.(*ExecuteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrdoService_BatchExecute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchExecuteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrdoServiceServer).BatchExecute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrdoService_BatchExecute_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrdoServiceServer).BatchExecute(ctx, req.(*BatchExecuteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrdoService_GetRuleSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRuleSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrdoServiceServer).GetRuleSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrdoService_GetRuleSet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrdoServiceServer).GetRuleSet(ctx, req.(*GetRuleSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrdoService_ListRuleSets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRuleSetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrdoServiceServer).ListRuleSets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrdoService_ListRuleSets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrdoServiceServer).ListRuleSets(ctx, req.(*ListRuleSetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrdoService_Eval_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrdoServiceServer).Eval(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrdoService_Eval_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrdoServiceServer).Eval(ctx, req.(*EvalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrdoService_Health_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrdoServiceServer).Health(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrdoService_Health_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrdoServiceServer).Health(ctx, req.(*HealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OrdoService_ServiceDesc is the grpc.ServiceDesc for OrdoService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OrdoService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ordo.v1.OrdoService",
	HandlerType: (*OrdoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Execute",
			Handler:    _OrdoService_Execute_Handler,
		},
		{
			MethodName: "BatchExecute",
			Handler:    _OrdoService_BatchExecute_Handler,
		},
		{
			MethodName: "GetRuleSet",
			Handler:    _OrdoService_GetRuleSet_Handler,
		},
		{
			MethodName: "ListRuleSets",
			Handler:    _OrdoService_ListRuleSets_Handler,
		},
		{
			MethodName: "Eval",
			Handler:    _OrdoService_Eval_Handler,
		},
		{
			MethodName: "Health",
			Handler:    _OrdoService_Health_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ordo.proto",
}
